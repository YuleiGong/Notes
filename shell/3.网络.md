# 网络

## wget 下载文件

```
#下载文件
wget URL
#指定重试次数
wget -t 5 URL
#不停的重试
wget -t 0 URL
#断点断续
wget -C URL
```

## 以纯文本的形式下载网页
* 用lynx命令的-dump选项将网页内容以ASCII编码的形式存储到文本文件中,省去了正则表达式解析

```
lynx URL -dump > file.txt
```
## cURL
* cURL 通常将下载文件输出到stdout,进度信息输出到stderr,cURL用途广泛，包括了下载，发送http请求等

```
#下载的文件输出到终端
curl http://www.baidu.com
#指定写入的文件名
curl http://www.baidu.com -o index.html
```
* 指定cookie

```
curl http://example.com --cookie "user=slynux;pass=hack"
```

* 存储cookie

```
curl http://www.baidu.com --cookie-jar cookie_fil
```

* 设置用户代理字符串

```
curl URL --user-agent "Mozilla/5.0"
curl -H "Host: www.slynux.org" -H "Accept-language: en" URL
```

* 进行认证

```
#-u 指定用户名和密码
curl -u user:pass http://test_auth.com
```

* 只打印头部信息

```
[dev@localhost 4.0]$ curl -I http://www.baidu.com
HTTP/1.1 200 OK
Accept-Ranges: bytes
Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform
Connection: Keep-Alive
Content-Length: 277
Content-Type: text/html
Date: Fri, 09 Nov 2018 14:56:59 GMT
Etag: "575e1f8a-115"
Last-Modified: Mon, 13 Jun 2016 02:50:50 GMT
Pragma: no-cache
Server: bfe/1.0.8.18
```

* 发送Post请求,-d的字符串参数的形式类似于GET请求。每对var=value之间用&分隔。
* -d后面的参数应该使用双引号，否者&会被shell解析为后台运行

```
curl URL -d "postvar=postdata2&postvar2=postdata2"
```

## ifconfig
* 网络接口用于将主机连接到网络,如eth0 eth1 usb9 wlan0等 
* __HWaddr__ 是硬件地址,MAC地址
* __inet__ 是IP地址
* __bcast__ 是广播地址
* __mask__ 子网掩码


```
ifconfig
eth0      Link encap:Ethernet  HWaddr 00:0C:29:F0:84:07
          inet addr:192.168.0.110  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::20c:29ff:fef0:8407/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:705964 errors:0 dropped:0 overruns:0 frame:0
          TX packets:490843 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:224629785 (214.2 MiB)  TX bytes:422985956 (403.3 MiB)

eth1      Link encap:Ethernet  HWaddr 00:0C:29:F0:84:11
          inet addr:172.16.13.133  Bcast:172.16.13.255  Mask:255.255.255.0
          inet6 addr: fe80::20c:29ff:fef0:8411/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:176739 errors:0 dropped:0 overruns:0 frame:0
          TX packets:41534 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:181846492 (173.4 MiB)  TX bytes:10959131 (10.4 MiB)

eth2      Link encap:Ethernet  HWaddr 00:0C:29:F0:84:1B
          inet addr:192.168.0.108  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::20c:29ff:fef0:841b/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:144298 errors:0 dropped:0 overruns:0 frame:0
          TX packets:37341 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:27286142 (26.0 MiB)  TX bytes:14309119 (13.6 MiB)

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:73038 errors:0 dropped:0 overruns:0 frame:0
          TX packets:73038 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:4789357 (4.5 MiB)  TX bytes:4789357 (4.5 MiB)

```
* 在软件层面修改MAC地址,重启失效

```
ifconfig eth0 hw ether 00:1c:bf:87:25:d5
```

* DNS域名服务器

```
#本地域名服务器
[dev@localhost 4.0]$ cat /etc/resolv.conf
; generated by /sbin/dhclient-script
nameserver 192.168.0.1

```

* 如果不使用DNS服务器,也可以为IP地址添加符号名

```
echo 192.168.0.9 backupserver >> /etc/hosts
```

## 使用ping
* ping 命令可以检查两台主机之间的连通性,如果向某台主机发送echo 分组，如果分组能够到达，且主机处于活动状态，会返回响应。


* 可以使用-c选项来限制发送包的数量

```
[dev@localhost 4.0]$ ping 127.0.0.1 -c 2
PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.018 ms
64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.033 ms

--- 127.0.0.1 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 999ms
rtt min/avg/max/mdev = 0.018/0.025/0.033/0.009 ms
```

## ssh
* ssh采用交互方式询问用户密码，一旦认证成功，将会为用户返回一个shell。
* ssh服务器默认在端口22上运行。但有些SSH服务器并没有使用这个端口。针对这种情况，可以用 SSH的-p port_num来指定端口。

```
ssh username@remote_host
```

## ssh 无密码登陆

* ssh采用了__非对称加密技术__，认证密钥包含两部分:一个__公钥__和一个__私钥__。我们可以通过 ssh-keygen命令创建认证密钥。要想实现自动化认证，公钥必须放置在服务器中(将其加入文件 ~/.ssh/authorized_keys)，与公钥对应的私钥应该放入登录客户机的 ~/.ssh目录中。另一些与SSH相关的 配置信息(例如，arthorized_keys文件的路径与名称)可以通过修改文件 /etc/ssh/sshd_config进行配置。


```
ssh-keygen -t rsa
~/.ssh/id_rsa.pub 公钥需要放入服务器的~/.ssh/authorized_keys中
```


## 使用ssh进行端口转发

* 端口转发允许其他计算机利用你的主机来连接到远程服务器上的特定服务。
* ssh -L 本地端口转发
    * __应用场景__:远程主机开启了一个8000端口服务，本地主机需要访问这个服务
    * __远程主机__ 通过```python -m SimpleHTTPServer``` 启动了一个8000的http服务端口,本地访问形式可能如下 ```curl http://remote:8000```
    * __本地主机__ 执行命令 ```ssh -L localhost:2000:localhost:8000 remote_user@remote_host```
    * 设置好后，可以在本地通过访问```curl http://localhost:2000``` 来代替直接访问服务器8000端口
    * 我们在__本地主机__上的应用将数据发送到本机的2000 端口上，而本机的__SSH Client__会将7001端口收到的数据加密并转发到__远程主机__的__SSH Server__上。
__SSH Server__会解密收到的数据并将之转发到远程主机监听的8000端口上,最后再将从8000端口返回的数据原路返回以完成整个流程。

* ssh -R 远程端口转发
    * __应用场景__:本地主机运行了一个服务，端口为8000，远程主机需要访问这个服务,通常,本地主机是没有公网ip的,云远程主机是无法访问这个服务的
    * __本地主机__ 通过```python -m SimpleHTTPServer``` 启动了一个8000的http服务端口,远程主机访问形式可能如下 ```curl http://本地主机ip:8000```
    * __本地主机__ 执行命令 ```ssh -R localhost:2000:localhost:8000 remote_user@remote_host```
    * 设置好后，可以在远程主机通过访问```curl http://localhost:2000``` 来代替直接访问本地服务器8000端口

## 端口分析

### lsof

* 列出系统中开放的端口和运行在端口之上的服务

```
[dev@localhost ~]$ sudo lsof -i
[sudo] password for dev:
COMMAND     PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
portreser  1367   root    5u  IPv4  12482      0t0  UDP *:dhcp-failover
portreser  1367   root    7u  IPv4  12484      0t0  UDP *:dhcp-failover2
sshd       1553   root    3u  IPv4  12798      0t0  TCP *:ssh (LISTEN)
sshd       1553   root    4u  IPv6  12807      0t0  TCP *:ssh (LISTEN)
xinetd     1564   root    5u  IPv4  12852      0t0  UDP *:tftp
mysqld     1648  mysql   16u  IPv6  12935      0t0  TCP *:mysql (LISTEN)
master     1754   root   12u  IPv4  13137      0t0  TCP localhost:smtp (LISTEN)
master     1754   root   13u  IPv6  13138      0t0  TCP localhost:smtp (LISTEN)
dhclient   5658   root    6u  IPv4  21261      0t0  UDP *:bootpc
java       8359  draco  123u  IPv6  36748      0t0  TCP *:postgres (LISTEN)
java       8359  draco  137u  IPv6  36768      0t0  TCP *:4200 (LISTEN)
java       8359  draco  162u  IPv6  36783      0t0  TCP *:corelccam (LISTEN)
oracle    19168 oracle   17u  IPv6 140612      0t0  UDP localhost:56206
oracle    19188 oracle   29u  IPv6 143570      0t0  UDP *:ansysli
oracle    19196 oracle   26u  IPv6 141111      0t0  UDP *:26247
oracle    19200 oracle   16u  IPv6 140784      0t0  UDP localhost:4245
oracle    19200 oracle   17u  IPv6 140792      0t0  TCP *:14209 (LISTEN)
oracle    19202 oracle   16u  IPv6 140804      0t0  UDP localhost:rkb-oscs
tnslsnr   19323 daemon   11u  IPv4 141537      0t0  TCP *:ncube-lm (LISTEN)
sshd      27692   root    3r  IPv4 227549      0t0  TCP 172.16.13.133:ssh->172.16.13.1:51950 (ESTABLISHED)
sshd      27695    dev    3u  IPv4 227549      0t0  TCP 172.16.13.133:ssh->172.16.13.1:51950 (ESTABLISHED)
```

### netstat 查看开放端口与服务

* netstat -tnp列出开放端口与服务

```
[dev@localhost ~]$ sudo netstat -tnp
[sudo] password for dev:
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address               Foreign Address             State       PID/Program name
tcp        0      0 172.16.13.133:22            172.16.13.1:51950           ESTABLISHED 27692/sshd
tcp        0      0 172.16.13.133:22            172.16.13.1:56119           ESTABLISHED 28147/sshd
```

## 创建套接字
* 使用__nc__命令来创建两个套接字，一个用来__侦听__，一个用来__连接__

```
# 侦听
[dev@localhost ~]$ nc -l 1234
# 连接该套接字，然后发送信息
[dev@localhost ~]$ nc localhost 1234
11111
#传输文件
nc -l 1234 > copy
nc localhost 1234 < supervisor.md
```

## 使用iptables 假设简易防火墙

```
#阻塞发送到8.8.8.8的流量包
sudo iptables -A OUTPUT -d 8.8.8.8 -j DROP
#阻塞发送到特定端口的流量
iptables -A OUTPUT -p tcp -dport 21 -j DROP
```

* __iptables__是Linux系统中用来架设防火墙的标准命令。iptables中的第一个选项:
    * -A 表明向__链 (chain)__中添加一条新的规则，该规则由后续参数给出。链就是一组规则的集合,我们使用的是OUTPUT链，它可以对所有__出站(outgoing)__的流量进行控制。
    * -d指定了所要匹配的分组目的地址
    * 随后使用-j来使__iptables__丢弃(DROP)
    * -p 指定该规则是适用于TCP
    * -dport指定了对应的端口
* iptables --flush 可以重置改动

