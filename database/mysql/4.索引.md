# 索引

## 索引的常见模型

* 哈希表:
  * 一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。
  * 因为不是有序的，所以哈希索引做区间查询的速度是很慢的。

  ***哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎***

* 有序数组:
  * 有序数组在等值查询和范围查询场景中的性能就都非常优秀
  * 在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。

  ***有序数组索引只适用于静态存储引擎***

* 二叉搜索树:
  * 二叉搜索树的特点是：父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。这样搜索会大大加快。
  * 为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。

  ***N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式***

## InnoDB 的索引模型

* 每一个索引在 InnoDB 里面对应一棵 B+ 树。
* 存储示例:

  ```shell
  mysql> create table T(
  id int primary key, 
  k int not null, 
  name varchar(16),
  index (k))engine=InnoDB;
  ```
  * 表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。
  ![index.png](https://i.loli.net/2021/04/26/uRFlnM48hj6WAY7.png)
  * 根据叶子节点的内容，索引类型分为主键索引(特殊的唯一索引)和非主键(普通索引)索引。主键索引的叶子节点存的是整行数据。非主键索引的叶子节点内容是主键的值。
  * __查询__:``` select id from T where k=5  ``` 对于 __普通索引__ 来说，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录，直到碰到第一个不满足 k=5 条件的记录。对于 __唯一索引__ 来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。由于InnoDB是按照数据页来读取数据的，带来的性能差距微乎其微。
  * __更新__: 对于插入操作来说，普通索引因为不用判断唯一性，可以直接将数据插入__change_buffer__ ，减少磁盘的IO。 对于唯一索引，因为需要判断唯一性，假设数据页不在内存中，需要将数据读入内存，插入速度会很慢。
* __change_buffer__ : 数据可以先放到change_buffer 中，引擎会自动在需要的时候合并到磁盘，提升写入速度，。对于写多读少的业务场景。change_buffer 会显著提升数据库效率。如果查询的需求很多，change_buffer 可能会出现副作用。因为需要不断的merge 数据到磁盘。

***基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。***

## 索引维护

* B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护,如果插入所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为 __页分裂__。
* 除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。
  * 自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。
  * 除了性能外，我们还可以从存储空间的角度来看,由于每个非主键索引的叶子节点上都是主键的值。显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。


## 覆盖索引

* 良好的sql语句和使用联合索引，可以避免 __回表__。
  * ``` select ID from T where k between 3 and 5 ``` 这条查询语句，因为需要查询的目标字段是Id主键，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。
  * 使用联合索引。联合索引的值也会被保存在索引树上，避免回表。

## 最左前缀原则

* B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。
* name，age 这个联合索引来分析: 联合索引先根据第一个字段排序，如果第一个字段有相同的，就按照第二个字段排序
![联合索引.jpg](https://i.loli.net/2021/04/26/ayGmcPtFUx2QgjX.jpg)
  * SQL 语句的条件是"where name like ‘张 %’"。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。

***只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。***
***因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了***




