# TCP

## TCP 头

![tpc头.jpg](https://i.loli.net/2021/03/20/xfHiLNlJ2zjCB67.jpg)

***顺序问题 ，稳重不乱；丢包问题，承诺靠谱；连接维护，有始有终；流量控制，把握分寸；拥塞控制，知进知退***

* 源端口号和目标端口号是不可少的，这一点和 UDP 是一样的。
* __包的序号__ 。通过给包编号，解决乱序的问题。确认哪个应该先来，哪个应该后到呢。
* __确认序号__。发出去的包应该有确认，如果没有收到就应该重新发送，直到送达。这个可以解决不丢包的问题。
* __状态位__。SYN 是发起一个连接，ACK 是回复，RST 是重新连接，FIN 是结束连接等。TCP 是面向连接的，因为双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。
* __窗口大小__。TCP 要做流量控制，通信双方各声明一个窗口，标识自己当前能够的处理能力，控制发送速度。

## TCP 的三次握手

### 建立连接，各自确认双方存在

* TCP 的连接建立，我们常常称为 __三次握手__ :
  * A：您好，我是 A。
  * B：您好 A，我是 B。
  * A：您好 B。

* 我们也常称为“请求 -> 应答 -> 应答之应答”的三个回合 *
* 三次握手，只需要双方发出的消息都有响应， a发送消息给b， b回复消息给a（a收到发送消息的响应，这个过程之后a认为可以连通b, 但b不知道是否可以连通a)。 a回复消息给b(b收到消息响应，b认为可以连通b, 此时a和b正式建立连接)
* A 和 B 建立了连接之后，A 会马上发送数据的，一旦 A 发送数据，则很多问题都得到了解决。
* 如果建立连接和，A不发送数据，我们在程序设计的时候，可以要求开启 keepalive 机制，即使没有真实的数据包，也有__探活包__。
* 作为服务端 B 的程序设计者，对于 A 这种长时间不发包的客户端，可以主动关闭，从而空出资源来给其他客户端使用。
* 在建立连接的过程中，双方都需要维护一个状态机:
![tcp_conn.jpg](https://i.loli.net/2021/03/20/eCJDAPuUWjInmwz.jpg)

### 约定初始数据包序号 ?

## TCP 四次挥手

![tcp_close.jpg](https://i.loli.net/2021/03/20/MpHnijPGKdqWhN8.jpg)

## TCP 状态机

![tcp状态机.jpg](https://i.loli.net/2021/03/20/TM49hNKdBzRGZJ2.jpg)

* 阿拉伯数字的序号，是连接过程中的顺序，大写中文数字的序号，是连接断开过程中的顺序。
* 加粗的实线是客户端 A 的状态变迁，加粗的虚线是服务端 B 的状态变迁。

## TCP 应答

* 为了保证包顺序性，每一个包都有一个 ID。在建立连接的时候，协议会约定起始的 ID 是什么，然后按照 ID 一个个发送。为了保证不丢包，对于发送的包都要进行应答(ACK)，但是这个应答也不是一个一个来的，而是会应答某个之前的 ID，表示之前的都收到了，这种模式称为 __累计确认__ 或者 __累计应答__ 。
* 为了记录所有发送的包和接收的包，TCP 也需要发送端和接收端分别都有缓存来保存这些记录
  * 发送方: 第一部分：发送了并且已经确认的。第二部分：发送了并且尚未确认的。第三部分：没有发送，但是已经等待发送的。第四部分：没有发送，并且暂时还不会发送的。
  * 接收端: 第一部分：接受并且确认过的。第二部分：还没接收，但是马上就能接收的。第三部分：还没接收，也没法接收的。

## 确认与重发机制

* __超时重试__ :
  * 对每一个发送了，但是没有 ACK 的包，都有设一个定时器，超过了一定的时间，就重新尝试。但是这个超时的时间如何评估呢？这个时间不宜过短，时间必须大于往返时间 RTT，否则会引起不必要的重传。也不宜过长，这样超时时间变长，访问就变慢了。 由于重传时间是不断变化的，自适应重传算法计算出合适的时间。
  * 每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。
* __快速重传__:
  * 当接收方收到一个序号大于下一个所期望的报文段时，就会检测到数据流中的一个间隔，于是它就会发送冗余的 ACK，仍然 ACK 的是期望接收的报文段。而当客户端收到三个冗余的 ACK 后，就会在定时器过期之前，重传丢失的报文段。

## 流量控制

* 在对于发送方包的确认中，同时会携带一个窗口的大小。发送方会根据这个窗口大小来调节需要发送的包数量。
* 如果接受到的窗口大小为0，发送方就会停止发送。发送方会定时发送 __窗口探测__ 数据包，看是否有机会调整窗口的大小。当接收方比较慢的时候，要防止低能窗口综合征，别空出一个字节来就赶快告诉发送方，然后马上又填满了，可以当窗口太小的时候，不更新窗口，直到达到一定大小，或者缓冲区一半为空，才更新窗口。

## 拥塞控制

* 拥塞控制是通过拥塞窗口来解决的，相当于往管道里面倒水，快了容易溢出，慢了浪费带宽，要摸着石头过河，找到最优值。
* TCP 的拥塞控制就是在不堵塞，不丢包的情况下，尽量发挥带宽。
* TCP BBR 拥塞算法
