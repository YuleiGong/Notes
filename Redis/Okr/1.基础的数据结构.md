# 1 基本的数据结构

![基础的数据结构.png](https://i.loli.net/2020/10/13/aWKg9Z8dlVOUeCG.png)
* redis 本身的key - value 结构使用一个 __全局哈希表__ 来存储。每个元素存储了key 和 value 的指针。

## 1.1 List 列表
* 内部是一个双向链表，表头的表尾的操作很快，索引查询很慢(O(N))。
* 常用来模拟异步队列(queue)和栈(stack)。
* 很多异步任务框架，都会使用Redis 的List 数据结构来作为broker转发消息。例如python-Celery go-Machinery

***慎用 lrange lindex 命令，数据量很大的时候，查询很慢***

## 1.2 Hash 字典
* 内部使用数组+链表来实现，如果出现散列冲突。会将冲突的元素使用链表串起来。如果冲突过多，Redis 会对原有哈希表扩容，触发rehash。

![hash 散列冲突-2.png](https://i.loli.net/2020/10/14/6mlJZBzN1GodTaP.png)

## 1.3 Set 集合
* 类似value 为Null 的字典，有去重的功能。集合中的元素唯一且无序

## 1.4 Zset 有序集合
* 像集合一样，保证了唯一，同时提供了Score，代表了Zset中每个值的排序权重。
* 内部使用 __跳表__ 实现，通过多级索引。实现快速查询。

![跳表示例.jpg](https://i.loli.net/2020/10/14/K2HbxBk3l7JUhGL.jpg)


# 2 基本应用

## 2.1 单点分布式锁
* redis 2.6以上版本中，使用ex (设置超时时间:避免死锁) nx (key 不存在时，才进行设置) 选项，可以原子的设置锁。
* 在释放锁的时候需要检查uuid 是否和设置的一致。保证释放锁的线程和加锁的线程一致。
* 线程匹配Uid 和 删除key 并不是一个原子操作。在需要的时候，可能需要使用Lua 脚本来完成这一操作保证原子性。
#FIXME 补充示例

```
127.0.0.1:6379> set lock uuid ex 5 nx
OK
```
*** 上述锁不能解决超时问题，如果加锁和释放锁的业务代码时间过长，超过了超时时间，锁被自动释放。其他线程重新持有这把锁，可能会使业务逻辑混乱 ***

## 2.2 集群分布式锁
* 集群模式下。如果某一进程持有主节点的锁。这时恰好主节点挂掉，数据还来不及同不到从节点。锁就会失效。

## 2.3 Scan 使用 - 使用scan key 作为例子
![hash 散列冲突-2.png](https://i.loli.net/2020/10/14/6mlJZBzN1GodTaP.png)
* scan 使用游标分步查询，不会阻塞redis服务的主线程。
* 服务器无需保存游标，游标的唯一状态就是scan 返回给客户端的值，每次scan遍历，返回的游标，其实是数组对应的 __下标(solt)__
* 单次scan 结果为空不意味着遍历结束(有可能当前的solt上恰好没有挂载着数据)，需要看返回的游标是否为0，

## 2.4 管道使用
* 使用管道可以极大的节省网络资源，提升响应时间。

```
# 10000个请求，50个并发连接 执行set命令的qps
➜  v8@v8.0.0-beta.6 redis-benchmark -t set -n 10000 -c 50 -q
SET: 106382.98 requests per second
# 10000个请求，50个并发连接 使用管道执行set命令，每个管道100个请求的qps
➜  v8@v8.0.0-beta.6 redis-benchmark -t set -n 10000 -c 50 -q -P 100
SET: 714285.69 requests per second

```

## 2.4 事物相关指令
* multi-表示事物开始 exec-表示事物开始执行 discard-丢弃事物
* 被multi 包围的指令，会被放入事物队列中，依次执行。

```
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> INCR index 
QUEUED
127.0.0.1:6379> INCR index
QUEUED
127.0.0.1:6379> EXEC
```

* redis 中的事物不具备原子性

```
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> set index hello
QUEUED
127.0.0.1:6379> INCR index
QUEUED
127.0.0.1:6379> set index world
QUEUED
127.0.0.1:6379> EXEC
1) OK
2) (error) ERR value is not an integer or out of range
3) OK
127.0.0.1:6379> get index
"world"
```
* watch 监听: watch 会在事物开始前监听一个变量，如果在监听后，该变量发生改变。exec指令会执行失败。

```
127.0.0.1:6379> watch books
OK
127.0.0.1:6379> INCR books
(integer) 3
127.0.0.1:6379> get books
"3"
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> INCR books
QUEUED
127.0.0.1:6379> EXEC ;;执行失败
(nil)
```

## 2.5 哨兵模式
* __sentinel__ 负责持续监控redis 主从节点的健康，主节点挂掉，会主动选择从节点切换成主节点。
![redis 哨兵.png](https://i.loli.net/2020/10/20/GZwSJBlo1HPQyU3.png)

![redis 从节点升级.png](https://i.loli.net/2020/10/20/TFEosRx5CkJfYDp.png)

## 3 横向扩展(集群方案)
* Redis Cluster 方案 
* Codis 中间件方案


# 4 redis 服务指令处理模型
* redis 服务端，一条指令的网络io 和 数据的操作是在一个单线程中完成的。很多指令操作，为了保证原子性，使用多线程并不能提升多少性能，故而使用单线程模型。

![redis epoll.png](https://i.loli.net/2020/10/25/LZivc98HIjDqphK.png)


# 5 备份
## 5.1 AOF
* Redis 写后日志，redis 先执行命令，数据写入内存完毕后，才写入日志文件。采用这种方式，写入的命令一定是成功的，redis可以避免恢复数据的时候，出现指令错误。
* 指令写AOF 策略
    * Always: 同步写，每次执行成功指令，主线程立即写到磁盘AOF文件。数据最大程度不会丢失，可能会影响性能。
    * Everysec: 每秒刷新一次AOF缓存。每次执行完指令，日志文件写入到AOF缓冲中，不立即写磁盘。 可能会丢失数据。
    * No:操作系统自己控制AOF缓存的持久化磁盘。 可能会丢失数据。
## 5.2 RDB 
* redis 会将某一个时刻的内存数据写入磁盘，redis宕机，使用此快照快速修复。 
* redis 会使用save(阻塞主线程) 和bgsave(不阻塞) 来写快照。
* 系统中一般会定时执行快照，保证宕机的时候数据不会丢失太多。

## 5.3 AOF+RDB
* RDB快照以一定的频率执行，在这个频率之间，使用AOF的方式增量的记录命令变更。保证AOF文件不会太大，同时RDB快照不用每次都频繁的执行全量备份。 
* 如果要求数据不等丢失，最好混合使用两种备份操作。

# 6 主从模式
* 一个读写分离的主从模式如下:
![redis 主从.png](https://i.loli.net/2020/10/28/uqBQLwrpIktOyG7.png)

* 主从模式下，redis只允许在主节点执行写入操作，从节点执行读操作。这样可以有效避免主从数据不一致。
* 从库加入到节点中后，主库会异步生成一次RDB全量文件，从库进行同步。在这个时间间歇，主库会将数据变动写入一个缓冲区，从库同步完成后，将缓冲的数据变动写入，保证主从一直。
* 一旦从库完成全量复制，主库和从库间会一直维护一个长链接，保证数据实时同步。

# 7 哨兵机制





