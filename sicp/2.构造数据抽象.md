# 构造数据抽象

![构造数据抽象.png](https://i.loli.net/2020/09/19/uhPNfOW8ZgKylen.png)

* 不同的数据对象组合起来，构成复合数据的方式，称为数据抽象。

## 1 抽象数据导引

### 1.1 有理数运算

* 对于有理数，直接使用分数来描述 + - * / 计算过程。

#### 1.1.1 序对

* 使用序对来描述一个有理数，分子代表序对的第一个元素，分母代表第二个元素。

    ```scheme
    (define (make-rat n d) (cons n d))
    ;;分子
    (define (numer x) (car x))
    ;;分母
    (define (denom x) (cdr x))
    ```

#### 1.1.2 有理数表示

* 使用分数计算规则来计算 + - * /
* 使用 print-rat 来表示一个有理数

  ```scheme
  define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
              (* (numer y) (denom x)))
              (* (denom x) (denom y))))

  (define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
              (* (numer y) (denom x)))
              (* (denom x) (denom y))))

  (define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))

  (define (div-rat x y)
  (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  ;;打印有理数
  (define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x))
  )
  ```

### 1.2 过程表示数据

* 可以将过程作为对象去操作，使用过程来表示复合数据。

* 使用过程实现序对。

  ```scheme
  ;;返回一个过程(dispatch)，根据过程的参数取到复合数据
  (define (cons x y)
  (define (dispatch m)
      (cond ((= m 0) x)
          ((= m 1) y)
          (else (error "Argument not 0 or 1 -- CONS" m))))
  dispatch)
  (define (car z) (z 0))
  (define (cdr z) (z 1))
  ```

## 2 层次性数据和闭包 

* 序对为我们提供了一种构造复合数据的 __粘合剂__。

### 2.1 序列的表示

* 利用序对可以构造出 __序列__ :一批数据对象的一种有序集合(__list__)。

![序列.png](https://i.loli.net/2020/09/13/prSv2DsXCyb9fBh.png)

* 通过嵌套的cons形成的这样一个序对的序列称为 __表__

    ```scheme
    (cons 1
        (cons 2
                (cons 3
                    (cons 4 nil))))
    ```

* scheme 提供了基本操作list 来构造表，无需使用嵌套的 cons

    ```scheme
    ;;取表的第N个元素
    (define (list-ref items n)
    (if (= n 0)
        (car items)
        (list-ref (cdr items) (- n 1))
    )
    )
    ;;取表的长度
    (define (length items)
    (if (null? items)
        0
        (+ 1 (length (cdr items)))
    )
    )
    ```

### 2.2 序列的map计算

* __map__: 使用一个定义好的过程，逐次应用于序列表中的各个元素，返回结果表。 map 帮助我们建立起了一道屏障，将实现序列变换的过程和提取表中的元素等等细节隔离开。

    ```scheme
    ;;放大或缩小
    (define (scale-list items factor)
    (map (lambda (x) (* x factor))
        items))
    ```

### 2.3 序列的层次性结构

* 使用序对构成序列，可以推广到元素本身也是序列的序列，我们称之为 __树__

![树.png](https://i.loli.net/2020/09/19/2vVSkrQsE7mL19f.png)

* 序列本身也是序列的元素形成了 __子树__，__树叶__ 构成了元素本身。

* 统计树的树叶数目，pair 用于判断该节点是否是序对(子树)

    ```scheme
    (define (count-leaves x)
    (cond ((null? x) 0)
        ((not (pair? x)) 1)
        (else (+ (count-leaves (car x))
                 (count-leaves (cdr x))))
        )
    )
    ```

### 2.4 树的map运算

* 使用递归方案实现对树的运算

    ```scheme
    ;;树的map运算
    (define (scale-tree tree factor)
    (cond ((null? tree) nil)
            ((not (pair? tree)) (* tree factor))
            (else (cons (scale-tree (car tree) factor)
                        (scale-tree (cdr tree) factor)))))

    ;;数的map运算
    (define (scale-tree tree factor)
    (map (lambda (sub-tree)
            (if (pair? sub-tree)
                (scale-tree sub-tree factor)
                (* sub-tree factor)))
        tree))
    ```

### 2.5 序列的信号流结构

* 在复杂的计算过程中，我们可以使用序列作为一个步骤到下一个步骤的 __信号__ ，每个步骤的计算过程可以大致抽象为 __枚举器enumerate__ __过滤器filter__ __映射map__ __累积器accumulate__，这种设计可以大大提高代码的清晰度。

![序列的信号流.png](https://i.loli.net/2020/09/19/5lzCUJvdSgPupqQ.png)

* 计算出一个树的奇数的叶子平方和：

    ```scheme
    (define (enumerate-tree tree);;枚举叶子节点
    (cond ((null? tree) nil)
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree))
                      (enumerate-tree (cdr tree))))))
    (define (filter predicate sequence) ;;过滤
    (cond ((null? sequence) nil)
            ((predicate (car sequence))
            (cons (car sequence)
                (filter predicate (cdr sequence))))
            (else (filter predicate (cdr sequence)))))
    ;: (filter odd? (list 1 2 3 4 5))

    ;: (map square (list 1 2 3 4 5))  ;;映射
    (define (accumulate op initial sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (accumulate op initial (cdr sequence)))))
    ;: (accumulate + 0 (list 1 2 3 4 5))
    ```

## 3 符号数据
