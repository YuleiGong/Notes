# 构造数据抽象

![构造数据抽象.png](https://i.loli.net/2020/09/13/xkolvUuqjYhypW2.png)

* 不同的数据对象组合起来，构成复合数据的方式，称为数据抽象。

## 1 抽象数据导引

### 1.1 有理数运算

* 对于有理数，直接使用分数来描述 + - * / 计算过程。

#### 1.1.1 序对

* 使用序对来描述一个有理数，分子代表序对的第一个元素，分母代表第二个元素。

    ```scheme
    (define (make-rat n d) (cons n d))
    ;;分子
    (define (numer x) (car x))
    ;;分母
    (define (denom x) (cdr x))
    ```

#### 1.1.2 有理数表示

* 使用分数计算规则来计算 + - * /
* 使用 print-rat 来表示一个有理数

  ```scheme
  define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
              (* (numer y) (denom x)))
              (* (denom x) (denom y))))

  (define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
              (* (numer y) (denom x)))
              (* (denom x) (denom y))))

  (define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))

  (define (div-rat x y)
  (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  ;;打印有理数
  (define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x))
  )
  ```

### 1.2 过程表示数据

* 可以将过程作为对象去操作，使用过程来表示复合数据。

* 使用过程实现序对。

  ```scheme
  ;;返回一个过程(dispatch)，根据过程的参数取到复合数据
  (define (cons x y)
  (define (dispatch m)
      (cond ((= m 0) x)
          ((= m 1) y)
          (else (error "Argument not 0 or 1 -- CONS" m))))
  dispatch)
  (define (car z) (z 0))
  (define (cdr z) (z 1))
  ```

## 2 层次性数据和闭包 

* 序对为我们提供了一种构造复合数据的粘合剂。

### 2.1 序列的表示

* 利用序对可以构造出的 __序列__:一批数据对象的一种有序集合。

![序列.png](https://i.loli.net/2020/09/13/prSv2DsXCyb9fBh.png)

* 通过嵌套的cons形成的这样一个序对的序列称为一个__表__

    ```scheme
    (cons 1
        (cons 2
                (cons 3
                    (cons 4 nil))))
    ```

* scheme 提供了基本操作list 来构造表

    ```scheme
    ;;取表的第N个元素
    (define (list-ref items n)
    (if (= n 0)
        (car items)
        (list-ref (cdr items) (- n 1))
    )
    )
    ;;取表的长度
    (define (length items)
    (if (null? items)
        0
        (+ 1 (length (cdr items)))
    )
    )
    ```

* __map__: 使用一个定义好的过程，逐次应用于序列表中的各个元素，返回结果表。 

    ```scheme
    ;;放大或缩小
    (define (scale-list items factor)
    (map (lambda (x) (* x factor))
        items))
    ```
